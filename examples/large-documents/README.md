# Large Document Example

In order to run this example, you need to be running a _Tenant Security Proxy_ (TSP) on your machine.
Check the **README.md** file in the parent directory to see how to start the TSP, if you haven't done so
yet.

Once the TSP is running, you can experiment with this example Node program. It illustrates the basics of how
to use the Tenant Security Client (TSC) SDK to encrypt and decrypt data. The example code shows two scenarios:

* encryption and decryption of a record that you might store in a key-value store or a database, and
* encryption and decryption of a file.

To run the example, you will need to have a fairly new version of Node installed on your computer. Try a
`node -v` to see what version you are using. We tested the example code using v12.18.3.

If node is ready to go, execute these commands:

```bash
export API_KEY='0WUaXesNgbTAuLwn'
yarn
yarn start
```

We've assigned an API key for you, but in production you will make your own and edit the TSP
configuration with it.  This should produce output like:

```bash
yarn run v1.22.5
$ yarn tsc --target ES6 --sourceMap false --module CommonJS --outDir ./dist/src src/index.ts && node dist/src/index.js
$ /Users/bob/ICL/tenant-security-client-nodejs/examples/large-documents/node_modules/.bin/tsc --target ES6 --sourceMap false --module CommonJS --outDir ./dist/src src/index.ts
Using tenant tenant-gcp.
Time to encrypt all 5000 subdocs: 594.3184ms
Time to decrypt all 5000 subdocs: 210.363448ms
Time to encrypt two subdocs: 53.449432ms
Time to decrypt two subdocs: 54.742352ms
Done in 3.71s.
```

The time output is printed once all operations have finished, but are marked as the process of
encrypting, updating, and decrypting is taking place.

If you look in the directory, you'll find a *large-document.json* file. The example code used all
the `subDocs` in that file to produce the encrypted *\*.enc* files in the ***sub-docs/*** folder.
It produced a single *large-document.json.edek* file that contains the Encrypted Data Encryption Key
(EDEK) that is required to decrypt any of the sub-docs. It decrypted the first two `subDocs` that it
had encrypted, wrote them to *partial-large-document.json* modified their text, and re-encrypted them
using the same EDEK. It then used that EDEK to decrypt all of the *\*.enc* files (including the
re-encrypted ones) and recombine them, writing a *subdocuments-large-document.json* file whose content
matches the `subDocs` field on the original.

When you run the example, you should see a number of INFO outputs generated by your TSP indicating
that it was wrapping new DEKs using the KMS, then unwrapping a EDEKs.

If you would like to experiment with a different tenant, just do:

```bash
export TENANT_ID=<selected-tenant-ID>
yarn start
```

The list of available tenants is listed in the **README.md** in the parent directory.

If you set the tenant to **tenant-gcp-l** and run the node program, then compare the logs generate by the
TSP to the logs generated when you use **tenant-gcp**, you can see the difference
between using a KMS configuration that has key leasing enabled vs. one that does not.

## Additional Resources

If you would like some more in-depth information, our website features a section of technical
documentation about the [SaaS Shield product](https://ironcorelabs.com/docs/saas-shield/).
